// Code generated by protoc-gen-go.
// source: api.proto
// DO NOT EDIT!

/*
Package v1alpha is a generated protocol buffer package.

It is generated from these files:
	api.proto

It has these top-level messages:
	ImageFormat
	Image
	Network
	App
	Pod
	KeyValue
	PodFilter
	ImageFilter
	GlobalFlags
	Info
	Event
	EventFilter
	GetInfoRequest
	GetInfoResponse
	ListPodsRequest
	ListPodsResponse
	InspectPodRequest
	InspectPodResponse
	ListImagesRequest
	ListImagesResponse
	InspectImageRequest
	InspectImageResponse
	ListenEventsRequest
	ListenEventsResponse
	GetLogsRequest
	GetLogsResponse
	FetchImagesRequest
	FetchImagesResponse
	RemoveImagesRequest
	RemoveImagesResponse
*/
package v1alpha

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// ImageType defines the supported image type.
type ImageType int32

const (
	ImageType_IMAGE_TYPE_UNDEFINED ImageType = 0
	ImageType_IMAGE_TYPE_APPC      ImageType = 1
	ImageType_IMAGE_TYPE_DOCKER    ImageType = 2
	ImageType_IMAGE_TYPE_OCI       ImageType = 3
)

var ImageType_name = map[int32]string{
	0: "IMAGE_TYPE_UNDEFINED",
	1: "IMAGE_TYPE_APPC",
	2: "IMAGE_TYPE_DOCKER",
	3: "IMAGE_TYPE_OCI",
}
var ImageType_value = map[string]int32{
	"IMAGE_TYPE_UNDEFINED": 0,
	"IMAGE_TYPE_APPC":      1,
	"IMAGE_TYPE_DOCKER":    2,
	"IMAGE_TYPE_OCI":       3,
}

func (x ImageType) String() string {
	return proto.EnumName(ImageType_name, int32(x))
}
func (ImageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// InsecureOption defines the insecure option flags to be used.
type InsecureOption int32

const (
	InsecureOption_INSECURE_OPTION_NONE    InsecureOption = 0
	InsecureOption_INSECURE_OPTION_ALL     InsecureOption = 1
	InsecureOption_INSECURE_OPTION_IMAGE   InsecureOption = 2
	InsecureOption_INSECURE_OPTION_TLS     InsecureOption = 4
	InsecureOption_INSECURE_OPTION_ON_DISK InsecureOption = 8
	InsecureOption_INSECURE_OPTION_HTTP    InsecureOption = 16
	InsecureOption_INSECURE_OPTION_PUBKEY  InsecureOption = 32
)

var InsecureOption_name = map[int32]string{
	0:  "INSECURE_OPTION_NONE",
	1:  "INSECURE_OPTION_ALL",
	2:  "INSECURE_OPTION_IMAGE",
	4:  "INSECURE_OPTION_TLS",
	8:  "INSECURE_OPTION_ON_DISK",
	16: "INSECURE_OPTION_HTTP",
	32: "INSECURE_OPTION_PUBKEY",
}
var InsecureOption_value = map[string]int32{
	"INSECURE_OPTION_NONE":    0,
	"INSECURE_OPTION_ALL":     1,
	"INSECURE_OPTION_IMAGE":   2,
	"INSECURE_OPTION_TLS":     4,
	"INSECURE_OPTION_ON_DISK": 8,
	"INSECURE_OPTION_HTTP":    16,
	"INSECURE_OPTION_PUBKEY":  32,
}

func (x InsecureOption) String() string {
	return proto.EnumName(InsecureOption_name, int32(x))
}
func (InsecureOption) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// FetchOption defines the options to be used for fetching.
type FetchOption int32

const (
	FetchOption_FETCH_OPTION_NONE       FetchOption = 0
	FetchOption_FETCH_OPTION_NO_STORE   FetchOption = 1
	FetchOption_FETCH_OPTION_ONLY_STORE FetchOption = 2
)

var FetchOption_name = map[int32]string{
	0: "FETCH_OPTION_NONE",
	1: "FETCH_OPTION_NO_STORE",
	2: "FETCH_OPTION_ONLY_STORE",
}
var FetchOption_value = map[string]int32{
	"FETCH_OPTION_NONE":       0,
	"FETCH_OPTION_NO_STORE":   1,
	"FETCH_OPTION_ONLY_STORE": 2,
}

func (x FetchOption) String() string {
	return proto.EnumName(FetchOption_name, int32(x))
}
func (FetchOption) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// AppState defines the possible states of the app.
type AppState int32

const (
	AppState_APP_STATE_UNDEFINED AppState = 0
	AppState_APP_STATE_RUNNING   AppState = 1
	AppState_APP_STATE_EXITED    AppState = 2
)

var AppState_name = map[int32]string{
	0: "APP_STATE_UNDEFINED",
	1: "APP_STATE_RUNNING",
	2: "APP_STATE_EXITED",
}
var AppState_value = map[string]int32{
	"APP_STATE_UNDEFINED": 0,
	"APP_STATE_RUNNING":   1,
	"APP_STATE_EXITED":    2,
}

func (x AppState) String() string {
	return proto.EnumName(AppState_name, int32(x))
}
func (AppState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// PodState defines the possible states of the pod.
// See https://github.com/coreos/rkt/blob/master/Documentation/devel/pod-lifecycle.md for a detailed
// explanation of each state.
type PodState int32

const (
	PodState_POD_STATE_UNDEFINED PodState = 0
	// States before the pod is running.
	PodState_POD_STATE_EMBRYO    PodState = 1
	PodState_POD_STATE_PREPARING PodState = 2
	PodState_POD_STATE_PREPARED  PodState = 3
	// State that indicates the pod is running.
	PodState_POD_STATE_RUNNING PodState = 4
	// States that indicates the pod is exited, and will never run.
	PodState_POD_STATE_ABORTED_PREPARE PodState = 5
	PodState_POD_STATE_EXITED          PodState = 6
	PodState_POD_STATE_DELETING        PodState = 7
	PodState_POD_STATE_GARBAGE         PodState = 8
)

var PodState_name = map[int32]string{
	0: "POD_STATE_UNDEFINED",
	1: "POD_STATE_EMBRYO",
	2: "POD_STATE_PREPARING",
	3: "POD_STATE_PREPARED",
	4: "POD_STATE_RUNNING",
	5: "POD_STATE_ABORTED_PREPARE",
	6: "POD_STATE_EXITED",
	7: "POD_STATE_DELETING",
	8: "POD_STATE_GARBAGE",
}
var PodState_value = map[string]int32{
	"POD_STATE_UNDEFINED":       0,
	"POD_STATE_EMBRYO":          1,
	"POD_STATE_PREPARING":       2,
	"POD_STATE_PREPARED":        3,
	"POD_STATE_RUNNING":         4,
	"POD_STATE_ABORTED_PREPARE": 5,
	"POD_STATE_EXITED":          6,
	"POD_STATE_DELETING":        7,
	"POD_STATE_GARBAGE":         8,
}

func (x PodState) String() string {
	return proto.EnumName(PodState_name, int32(x))
}
func (PodState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// EventType defines the type of the events that will be received via ListenEvents().
type EventType int32

const (
	EventType_EVENT_TYPE_UNDEFINED EventType = 0
	// Pod events.
	EventType_EVENT_TYPE_POD_PREPARED          EventType = 1
	EventType_EVENT_TYPE_POD_PREPARE_ABORTED   EventType = 2
	EventType_EVENT_TYPE_POD_STARTED           EventType = 3
	EventType_EVENT_TYPE_POD_EXITED            EventType = 4
	EventType_EVENT_TYPE_POD_GARBAGE_COLLECTED EventType = 5
	// App events.
	EventType_EVENT_TYPE_APP_STARTED EventType = 6
	EventType_EVENT_TYPE_APP_EXITED  EventType = 7
	// Image events.
	EventType_EVENT_TYPE_IMAGE_IMPORTED EventType = 8
	EventType_EVENT_TYPE_IMAGE_REMOVED  EventType = 9
)

var EventType_name = map[int32]string{
	0: "EVENT_TYPE_UNDEFINED",
	1: "EVENT_TYPE_POD_PREPARED",
	2: "EVENT_TYPE_POD_PREPARE_ABORTED",
	3: "EVENT_TYPE_POD_STARTED",
	4: "EVENT_TYPE_POD_EXITED",
	5: "EVENT_TYPE_POD_GARBAGE_COLLECTED",
	6: "EVENT_TYPE_APP_STARTED",
	7: "EVENT_TYPE_APP_EXITED",
	8: "EVENT_TYPE_IMAGE_IMPORTED",
	9: "EVENT_TYPE_IMAGE_REMOVED",
}
var EventType_value = map[string]int32{
	"EVENT_TYPE_UNDEFINED":             0,
	"EVENT_TYPE_POD_PREPARED":          1,
	"EVENT_TYPE_POD_PREPARE_ABORTED":   2,
	"EVENT_TYPE_POD_STARTED":           3,
	"EVENT_TYPE_POD_EXITED":            4,
	"EVENT_TYPE_POD_GARBAGE_COLLECTED": 5,
	"EVENT_TYPE_APP_STARTED":           6,
	"EVENT_TYPE_APP_EXITED":            7,
	"EVENT_TYPE_IMAGE_IMPORTED":        8,
	"EVENT_TYPE_IMAGE_REMOVED":         9,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}
func (EventType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// ImageFormat defines the format of the image.
type ImageFormat struct {
	// Type of the image, required.
	Type ImageType `protobuf:"varint,1,opt,name=type,enum=v1alpha.ImageType" json:"type,omitempty"`
	// Version of the image format, required.
	Version string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (m *ImageFormat) Reset()                    { *m = ImageFormat{} }
func (m *ImageFormat) String() string            { return proto.CompactTextString(m) }
func (*ImageFormat) ProtoMessage()               {}
func (*ImageFormat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Image describes the image's information.
type Image struct {
	// Base format of the image, required. This indicates the original format
	// for the image as nowadays all the image formats will be transformed to
	// ACI.
	BaseFormat *ImageFormat `protobuf:"bytes,1,opt,name=base_format" json:"base_format,omitempty"`
	// ID of the image, a string that can be used to uniquely identify the image,
	// e.g. sha512 hash of the ACIs, required.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// Name of the image in the image manifest, e.g. 'coreos.com/etcd', optional.
	Name string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// Version of the image, e.g. 'latest', '2.0.10', optional.
	Version string `protobuf:"bytes,4,opt,name=version" json:"version,omitempty"`
	// Timestamp of when the image is imported, it is the seconds since epoch, optional.
	ImportTimestamp int64 `protobuf:"varint,5,opt,name=import_timestamp" json:"import_timestamp,omitempty"`
	// JSON-encoded byte array that represents the image manifest, optional.
	Manifest []byte `protobuf:"bytes,6,opt,name=manifest,proto3" json:"manifest,omitempty"`
	// Size is the size in bytes of this image in the store.
	Size int64 `protobuf:"varint,7,opt,name=size" json:"size,omitempty"`
	// Annotations on this image.
	Annotations []*KeyValue `protobuf:"bytes,8,rep,name=annotations" json:"annotations,omitempty"`
	// Labels of this image.
	Labels []*KeyValue `protobuf:"bytes,9,rep,name=labels" json:"labels,omitempty"`
}

func (m *Image) Reset()                    { *m = Image{} }
func (m *Image) String() string            { return proto.CompactTextString(m) }
func (*Image) ProtoMessage()               {}
func (*Image) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Image) GetBaseFormat() *ImageFormat {
	if m != nil {
		return m.BaseFormat
	}
	return nil
}

func (m *Image) GetAnnotations() []*KeyValue {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Image) GetLabels() []*KeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

// Network describes the network information of a pod.
type Network struct {
	// Name of the network that a pod belongs to, required.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Pod's IPv4 address within the network, optional if IPv6 address is given.
	Ipv4 string `protobuf:"bytes,2,opt,name=ipv4" json:"ipv4,omitempty"`
	// Pod's IPv6 address within the network, optional if IPv4 address is given.
	Ipv6 string `protobuf:"bytes,3,opt,name=ipv6" json:"ipv6,omitempty"`
}

func (m *Network) Reset()                    { *m = Network{} }
func (m *Network) String() string            { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()               {}
func (*Network) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// App describes the information of an app that's running in a pod.
type App struct {
	// Name of the app, required.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Image used by the app, required. However, this may only contain the image id
	// if it is returned by ListPods().
	Image *Image `protobuf:"bytes,2,opt,name=image" json:"image,omitempty"`
	// State of the app. optional, non-empty only if it's returned by InspectPod().
	State AppState `protobuf:"varint,3,opt,name=state,enum=v1alpha.AppState" json:"state,omitempty"`
	// Exit code of the app. optional, only valid if it's returned by InspectPod() and
	// the app has already exited.
	ExitCode int32 `protobuf:"zigzag32,4,opt,name=exit_code" json:"exit_code,omitempty"`
	// Annotations for this app.
	Annotations []*KeyValue `protobuf:"bytes,5,rep,name=annotations" json:"annotations,omitempty"`
}

func (m *App) Reset()                    { *m = App{} }
func (m *App) String() string            { return proto.CompactTextString(m) }
func (*App) ProtoMessage()               {}
func (*App) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *App) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

func (m *App) GetAnnotations() []*KeyValue {
	if m != nil {
		return m.Annotations
	}
	return nil
}

// Pod describes a pod's information.
// If a pod is in Embryo, Preparing, AbortedPrepare state,
// only id and state will be returned.
//
// If a pod is in other states, the pod manifest and
// apps will be returned when 'detailed' is true in the request.
//
// A valid pid of the stage1 process of the pod will be returned
// if the pod is Running has run once.
//
// Networks are only returned when a pod is in Running.
type Pod struct {
	// ID of the pod, in the form of a UUID.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// PID of the stage1 process of the pod.
	Pid int32 `protobuf:"zigzag32,2,opt,name=pid" json:"pid,omitempty"`
	// State of the pod.
	State PodState `protobuf:"varint,3,opt,name=state,enum=v1alpha.PodState" json:"state,omitempty"`
	// List of apps in the pod.
	Apps []*App `protobuf:"bytes,4,rep,name=apps" json:"apps,omitempty"`
	// Network information of the pod.
	// Note that a pod can be in multiple networks.
	Networks []*Network `protobuf:"bytes,5,rep,name=networks" json:"networks,omitempty"`
	// JSON-encoded byte array that represents the pod manifest of the pod.
	Manifest []byte `protobuf:"bytes,6,opt,name=manifest,proto3" json:"manifest,omitempty"`
	// Annotations on this pod.
	Annotations []*KeyValue `protobuf:"bytes,7,rep,name=annotations" json:"annotations,omitempty"`
	// Cgroup of the pod, empty if the pod is not running.
	Cgroup string `protobuf:"bytes,8,opt,name=cgroup" json:"cgroup,omitempty"`
	// Timestamp of when the pod is created, nanoseconds since epoch.
	// Zero if the pod is not created.
	CreatedAt int64 `protobuf:"varint,9,opt,name=created_at" json:"created_at,omitempty"`
	// Timestamp of when the pod is started, nanoseconds since epoch.
	// Zero if the pod is not started.
	StartedAt int64 `protobuf:"varint,10,opt,name=started_at" json:"started_at,omitempty"`
	// Timestamp of when the pod is moved to exited-garbage/garbage,
	// in nanoseconds since epoch.
	// Zero if the pod is not moved to exited-garbage/garbage yet.
	GcMarkedAt int64 `protobuf:"varint,11,opt,name=gc_marked_at" json:"gc_marked_at,omitempty"`
}

func (m *Pod) Reset()                    { *m = Pod{} }
func (m *Pod) String() string            { return proto.CompactTextString(m) }
func (*Pod) ProtoMessage()               {}
func (*Pod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Pod) GetApps() []*App {
	if m != nil {
		return m.Apps
	}
	return nil
}

func (m *Pod) GetNetworks() []*Network {
	if m != nil {
		return m.Networks
	}
	return nil
}

func (m *Pod) GetAnnotations() []*KeyValue {
	if m != nil {
		return m.Annotations
	}
	return nil
}

type KeyValue struct {
	// Key part of the key-value pair.
	Key string `protobuf:"bytes,1,opt,name=Key" json:"Key,omitempty"`
	// Value part of the key-value pair.
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *KeyValue) Reset()                    { *m = KeyValue{} }
func (m *KeyValue) String() string            { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()               {}
func (*KeyValue) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// PodFilter defines the condition that the returned pods need to satisfy in ListPods().
// The conditions are combined by 'AND', and different filters are combined by 'OR'.
type PodFilter struct {
	// If not empty, the pods that have any of the ids will be returned.
	Ids []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
	// If not empty, the pods that have any of the states will be returned.
	States []PodState `protobuf:"varint,2,rep,packed,name=states,enum=v1alpha.PodState" json:"states,omitempty"`
	// If not empty, the pods that all of the apps will be returned.
	AppNames []string `protobuf:"bytes,3,rep,name=app_names" json:"app_names,omitempty"`
	// If not empty, the pods that have all of the images(in the apps) will be returned
	ImageIds []string `protobuf:"bytes,4,rep,name=image_ids" json:"image_ids,omitempty"`
	// If not empty, the pods that are in all of the networks will be returned.
	NetworkNames []string `protobuf:"bytes,5,rep,name=network_names" json:"network_names,omitempty"`
	// If not empty, the pods that have all of the annotations will be returned.
	Annotations []*KeyValue `protobuf:"bytes,6,rep,name=annotations" json:"annotations,omitempty"`
	// If not empty, the pods whose cgroup are listed will be returned.
	Cgroups []string `protobuf:"bytes,7,rep,name=cgroups" json:"cgroups,omitempty"`
	// If not empty, the pods whose these cgroup belong to will be returned.
	// i.e. the pod's cgroup is a prefix of the specified cgroup
	PodSubCgroups []string `protobuf:"bytes,8,rep,name=pod_sub_cgroups" json:"pod_sub_cgroups,omitempty"`
}

func (m *PodFilter) Reset()                    { *m = PodFilter{} }
func (m *PodFilter) String() string            { return proto.CompactTextString(m) }
func (*PodFilter) ProtoMessage()               {}
func (*PodFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PodFilter) GetAnnotations() []*KeyValue {
	if m != nil {
		return m.Annotations
	}
	return nil
}

// ImageFilter defines the condition that the returned images need to satisfy in ListImages().
// The conditions are combined by 'AND', and different filters are combined by 'OR'.
type ImageFilter struct {
	// If not empty, the images that have any of the ids will be returned.
	Ids []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
	// if not empty, the images that have any of the prefixes in the name will be returned.
	Prefixes []string `protobuf:"bytes,2,rep,name=prefixes" json:"prefixes,omitempty"`
	// If not empty, the images that have any of the base names will be returned.
	// For example, both 'coreos.com/etcd' and 'k8s.io/etcd' will be returned if 'etcd' is included,
	// however 'k8s.io/etcd-backup' will not be returned.
	BaseNames []string `protobuf:"bytes,3,rep,name=base_names" json:"base_names,omitempty"`
	// If not empty, the images that have any of the keywords in the name will be returned.
	// For example, both 'kubernetes-etcd', 'etcd:latest' will be returned if 'etcd' is included,
	Keywords []string `protobuf:"bytes,4,rep,name=keywords" json:"keywords,omitempty"`
	// If not empty, the images that have all of the labels will be returned.
	Labels []*KeyValue `protobuf:"bytes,5,rep,name=labels" json:"labels,omitempty"`
	// If set, the images that are imported after this timestamp will be returned.
	ImportedAfter int64 `protobuf:"varint,6,opt,name=imported_after" json:"imported_after,omitempty"`
	// If set, the images that are imported before this timestamp will be returned.
	ImportedBefore int64 `protobuf:"varint,7,opt,name=imported_before" json:"imported_before,omitempty"`
	// If not empty, the images that have all of the annotations will be returned.
	Annotations []*KeyValue `protobuf:"bytes,8,rep,name=annotations" json:"annotations,omitempty"`
	// If not empty, the images that have any of the exact full names will be returned.
	FullNames []string `protobuf:"bytes,9,rep,name=full_names" json:"full_names,omitempty"`
}

func (m *ImageFilter) Reset()                    { *m = ImageFilter{} }
func (m *ImageFilter) String() string            { return proto.CompactTextString(m) }
func (*ImageFilter) ProtoMessage()               {}
func (*ImageFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ImageFilter) GetLabels() []*KeyValue {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ImageFilter) GetAnnotations() []*KeyValue {
	if m != nil {
		return m.Annotations
	}
	return nil
}

// GlobalFlags describes the flags that passed to rkt api service when it is launched.
type GlobalFlags struct {
	// Data directory.
	Dir string `protobuf:"bytes,1,opt,name=dir" json:"dir,omitempty"`
	// System configuration directory.
	SystemConfigDir string `protobuf:"bytes,2,opt,name=system_config_dir" json:"system_config_dir,omitempty"`
	// Local configuration directory.
	LocalConfigDir string `protobuf:"bytes,3,opt,name=local_config_dir" json:"local_config_dir,omitempty"`
	// User configuration directory.
	UserConfigDir string `protobuf:"bytes,4,opt,name=user_config_dir" json:"user_config_dir,omitempty"`
	// Insecure flags configurates what security features to disable.
	InsecureFlags string `protobuf:"bytes,5,opt,name=insecure_flags" json:"insecure_flags,omitempty"`
	// Whether to automatically trust gpg keys fetched from https
	TrustKeysFromHttps bool `protobuf:"varint,6,opt,name=trust_keys_from_https" json:"trust_keys_from_https,omitempty"`
}

func (m *GlobalFlags) Reset()                    { *m = GlobalFlags{} }
func (m *GlobalFlags) String() string            { return proto.CompactTextString(m) }
func (*GlobalFlags) ProtoMessage()               {}
func (*GlobalFlags) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// Info describes the information of rkt on the machine.
type Info struct {
	// Version of rkt, required, in the form of Semantic Versioning 2.0.0 (http://semver.org/).
	RktVersion string `protobuf:"bytes,1,opt,name=rkt_version" json:"rkt_version,omitempty"`
	// Version of appc, required, in the form of Semantic Versioning 2.0.0 (http://semver.org/).
	AppcVersion string `protobuf:"bytes,2,opt,name=appc_version" json:"appc_version,omitempty"`
	// Latest version of the api that's supported by the service, required, in the form of Semantic Versioning 2.0.0 (http://semver.org/).
	ApiVersion string `protobuf:"bytes,3,opt,name=api_version" json:"api_version,omitempty"`
	// The global flags that passed to the rkt api service when it's launched.
	GlobalFlags *GlobalFlags `protobuf:"bytes,4,opt,name=global_flags" json:"global_flags,omitempty"`
}

func (m *Info) Reset()                    { *m = Info{} }
func (m *Info) String() string            { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()               {}
func (*Info) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Info) GetGlobalFlags() *GlobalFlags {
	if m != nil {
		return m.GlobalFlags
	}
	return nil
}

// Event describes the events that will be received via ListenEvents().
type Event struct {
	// Type of the event, required.
	Type EventType `protobuf:"varint,1,opt,name=type,enum=v1alpha.EventType" json:"type,omitempty"`
	// ID of the subject that causes the event, required.
	// If the event is a pod or app event, the id is the pod's uuid.
	// If the event is an image event, the id is the image's id.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// Name of the subject that causes the event, required.
	// If the event is a pod event, the name is the pod's name.
	// If the event is an app event, the name is the app's name.
	// If the event is an image event, the name is the image's name.
	From string `protobuf:"bytes,3,opt,name=from" json:"from,omitempty"`
	// Timestamp of when the event happens, it is the seconds since epoch, required.
	Time int64 `protobuf:"varint,4,opt,name=time" json:"time,omitempty"`
	// Data of the event, in the form of key-value pairs, optional.
	Data []*KeyValue `protobuf:"bytes,5,rep,name=data" json:"data,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Event) GetData() []*KeyValue {
	if m != nil {
		return m.Data
	}
	return nil
}

// EventFilter defines the condition that the returned events needs to satisfy in ListImages().
// The condition are combined by 'AND'.
type EventFilter struct {
	// If not empty, then only returns the events that have the listed types.
	Types []EventType `protobuf:"varint,1,rep,packed,name=types,enum=v1alpha.EventType" json:"types,omitempty"`
	// If not empty, then only returns the events whose 'id' is included in the listed ids.
	Ids []string `protobuf:"bytes,2,rep,name=ids" json:"ids,omitempty"`
	// If not empty, then only returns the events whose 'from' is included in the listed names.
	Names []string `protobuf:"bytes,3,rep,name=names" json:"names,omitempty"`
	// If set, then only returns the events after this timestamp.
	// If the server starts after since_time, then only the events happened after the start of the server will be returned.
	// If since_time is a future timestamp, then no events will be returned until that time.
	SinceTime int64 `protobuf:"varint,4,opt,name=since_time" json:"since_time,omitempty"`
	// If set, then only returns the events before this timestamp.
	// If it is a future timestamp, then the event stream will be closed at that moment.
	UntilTime int64 `protobuf:"varint,5,opt,name=until_time" json:"until_time,omitempty"`
}

func (m *EventFilter) Reset()                    { *m = EventFilter{} }
func (m *EventFilter) String() string            { return proto.CompactTextString(m) }
func (*EventFilter) ProtoMessage()               {}
func (*EventFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

// Request for GetInfo().
type GetInfoRequest struct {
}

func (m *GetInfoRequest) Reset()                    { *m = GetInfoRequest{} }
func (m *GetInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*GetInfoRequest) ProtoMessage()               {}
func (*GetInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

// Response for GetInfo().
type GetInfoResponse struct {
	Info *Info `protobuf:"bytes,1,opt,name=info" json:"info,omitempty"`
}

func (m *GetInfoResponse) Reset()                    { *m = GetInfoResponse{} }
func (m *GetInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*GetInfoResponse) ProtoMessage()               {}
func (*GetInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *GetInfoResponse) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

// Request for ListPods().
type ListPodsRequest struct {
	Filters []*PodFilter `protobuf:"bytes,1,rep,name=filters" json:"filters,omitempty"`
	Detail  bool         `protobuf:"varint,2,opt,name=detail" json:"detail,omitempty"`
}

func (m *ListPodsRequest) Reset()                    { *m = ListPodsRequest{} }
func (m *ListPodsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPodsRequest) ProtoMessage()               {}
func (*ListPodsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ListPodsRequest) GetFilters() []*PodFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// Response for ListPods().
type ListPodsResponse struct {
	Pods []*Pod `protobuf:"bytes,1,rep,name=pods" json:"pods,omitempty"`
}

func (m *ListPodsResponse) Reset()                    { *m = ListPodsResponse{} }
func (m *ListPodsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPodsResponse) ProtoMessage()               {}
func (*ListPodsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ListPodsResponse) GetPods() []*Pod {
	if m != nil {
		return m.Pods
	}
	return nil
}

// Request for InspectPod().
type InspectPodRequest struct {
	// ID of the pod which we are querying status for, required.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *InspectPodRequest) Reset()                    { *m = InspectPodRequest{} }
func (m *InspectPodRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectPodRequest) ProtoMessage()               {}
func (*InspectPodRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

// Response for InspectPod().
type InspectPodResponse struct {
	Pod *Pod `protobuf:"bytes,1,opt,name=pod" json:"pod,omitempty"`
}

func (m *InspectPodResponse) Reset()                    { *m = InspectPodResponse{} }
func (m *InspectPodResponse) String() string            { return proto.CompactTextString(m) }
func (*InspectPodResponse) ProtoMessage()               {}
func (*InspectPodResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *InspectPodResponse) GetPod() *Pod {
	if m != nil {
		return m.Pod
	}
	return nil
}

// Request for ListImages().
type ListImagesRequest struct {
	Filters []*ImageFilter `protobuf:"bytes,1,rep,name=filters" json:"filters,omitempty"`
	Detail  bool           `protobuf:"varint,2,opt,name=detail" json:"detail,omitempty"`
}

func (m *ListImagesRequest) Reset()                    { *m = ListImagesRequest{} }
func (m *ListImagesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListImagesRequest) ProtoMessage()               {}
func (*ListImagesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ListImagesRequest) GetFilters() []*ImageFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// Response for ListImages().
type ListImagesResponse struct {
	Images []*Image `protobuf:"bytes,1,rep,name=images" json:"images,omitempty"`
}

func (m *ListImagesResponse) Reset()                    { *m = ListImagesResponse{} }
func (m *ListImagesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListImagesResponse) ProtoMessage()               {}
func (*ListImagesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *ListImagesResponse) GetImages() []*Image {
	if m != nil {
		return m.Images
	}
	return nil
}

// Request for InspectImage().
type InspectImageRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *InspectImageRequest) Reset()                    { *m = InspectImageRequest{} }
func (m *InspectImageRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectImageRequest) ProtoMessage()               {}
func (*InspectImageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

// Response for InspectImage().
type InspectImageResponse struct {
	Image *Image `protobuf:"bytes,1,opt,name=image" json:"image,omitempty"`
}

func (m *InspectImageResponse) Reset()                    { *m = InspectImageResponse{} }
func (m *InspectImageResponse) String() string            { return proto.CompactTextString(m) }
func (*InspectImageResponse) ProtoMessage()               {}
func (*InspectImageResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *InspectImageResponse) GetImage() *Image {
	if m != nil {
		return m.Image
	}
	return nil
}

// Request for ListenEvents().
type ListenEventsRequest struct {
	Filter *EventFilter `protobuf:"bytes,1,opt,name=filter" json:"filter,omitempty"`
}

func (m *ListenEventsRequest) Reset()                    { *m = ListenEventsRequest{} }
func (m *ListenEventsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListenEventsRequest) ProtoMessage()               {}
func (*ListenEventsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *ListenEventsRequest) GetFilter() *EventFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

// Response for ListenEvents().
type ListenEventsResponse struct {
	// Aggregate multiple events to reduce round trips, optional as the response can contain no events.
	Events []*Event `protobuf:"bytes,1,rep,name=events" json:"events,omitempty"`
}

func (m *ListenEventsResponse) Reset()                    { *m = ListenEventsResponse{} }
func (m *ListenEventsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListenEventsResponse) ProtoMessage()               {}
func (*ListenEventsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *ListenEventsResponse) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

// Request for GetLogs().
type GetLogsRequest struct {
	// ID of the pod which we will get logs from, required.
	PodId string `protobuf:"bytes,1,opt,name=pod_id" json:"pod_id,omitempty"`
	// Name of the app within the pod which we will get logs
	// from, optional. If not set, then the logs of all the
	// apps within the pod will be returned.
	AppName string `protobuf:"bytes,2,opt,name=app_name" json:"app_name,omitempty"`
	// Number of most recent lines to return, optional.
	Lines int32 `protobuf:"varint,3,opt,name=lines" json:"lines,omitempty"`
	// If true, then a response stream will not be closed,
	// and new log response will be sent via the stream, default is false.
	Follow bool `protobuf:"varint,4,opt,name=follow" json:"follow,omitempty"`
	// If set, then only the logs after the timestamp will
	// be returned, optional.
	SinceTime int64 `protobuf:"varint,5,opt,name=since_time" json:"since_time,omitempty"`
	// If set, then only the logs before the timestamp will
	// be returned, optional.
	UntilTime int64 `protobuf:"varint,6,opt,name=until_time" json:"until_time,omitempty"`
}

func (m *GetLogsRequest) Reset()                    { *m = GetLogsRequest{} }
func (m *GetLogsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLogsRequest) ProtoMessage()               {}
func (*GetLogsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

// Response for GetLogs().
type GetLogsResponse struct {
	// List of the log lines that returned, optional as the response can contain no logs.
	Lines []string `protobuf:"bytes,1,rep,name=lines" json:"lines,omitempty"`
}

func (m *GetLogsResponse) Reset()                    { *m = GetLogsResponse{} }
func (m *GetLogsResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLogsResponse) ProtoMessage()               {}
func (*GetLogsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

// FetchImagesRequest defines the request for FetchImages.
type FetchImagesRequest struct {
	// Resolvable names of the image, it's expected to be a distribution string.
	// The format is 'cimd:DISTRIBUTION_TYPE:v=uint32(VERSION):string', e.g. 'cimd:docker:v=0:[REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]'.
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
	// Insecure options for fetch, it's a bitflag.
	InsecureOption InsecureOption `protobuf:"varint,2,opt,name=insecure_option,enum=v1alpha.InsecureOption" json:"insecure_option,omitempty"`
	// Whether to fetch from the store, or skip the store.
	FetchOption FetchOption `protobuf:"varint,3,opt,name=fetch_option,enum=v1alpha.FetchOption" json:"fetch_option,omitempty"`
	// Wether to trust keys from https connection.
	TrustKeysFromHttps bool `protobuf:"varint,4,opt,name=trust_keys_from_https" json:"trust_keys_from_https,omitempty"`
	// Whether to fetch the depedencies.
	WithDeps bool `protobuf:"varint,5,opt,name=with_deps" json:"with_deps,omitempty"`
	// Serialized credential config file, used for fetching.
	// The format is documented at:
	// https://github.com/coreos/rkt/blob/master/Documentation/configuration.md#rktkind-auth
	CredentialConfig []byte `protobuf:"bytes,6,opt,name=credential_config,proto3" json:"credential_config,omitempty"`
}

func (m *FetchImagesRequest) Reset()                    { *m = FetchImagesRequest{} }
func (m *FetchImagesRequest) String() string            { return proto.CompactTextString(m) }
func (*FetchImagesRequest) ProtoMessage()               {}
func (*FetchImagesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

// FetchImagesResponse defines the response for FetchImages.
type FetchImagesResponse struct {
	// IDs of the fetched images, which can be used to uniquely identify the images.
	// The order of the IDs corresponds to the names in the request.
	Ids []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
}

func (m *FetchImagesResponse) Reset()                    { *m = FetchImagesResponse{} }
func (m *FetchImagesResponse) String() string            { return proto.CompactTextString(m) }
func (*FetchImagesResponse) ProtoMessage()               {}
func (*FetchImagesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

// RemoveImagesRequest defines the request for RemoveImages.
type RemoveImagesRequest struct {
	// IDs of the images to remove, when specified, the images with these IDs
	// will be removed.
	Ids []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
	// Names of the images to remove, when specified, the images with these
	// names will be removed. If any image name is shared by multiple images,
	// all of them will be removed.
	Names []string `protobuf:"bytes,2,rep,name=names" json:"names,omitempty"`
}

func (m *RemoveImagesRequest) Reset()                    { *m = RemoveImagesRequest{} }
func (m *RemoveImagesRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveImagesRequest) ProtoMessage()               {}
func (*RemoveImagesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

// RemoveImagesResponse defines the response for RemoveImages.
type RemoveImagesResponse struct {
}

func (m *RemoveImagesResponse) Reset()                    { *m = RemoveImagesResponse{} }
func (m *RemoveImagesResponse) String() string            { return proto.CompactTextString(m) }
func (*RemoveImagesResponse) ProtoMessage()               {}
func (*RemoveImagesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func init() {
	proto.RegisterType((*ImageFormat)(nil), "v1alpha.ImageFormat")
	proto.RegisterType((*Image)(nil), "v1alpha.Image")
	proto.RegisterType((*Network)(nil), "v1alpha.Network")
	proto.RegisterType((*App)(nil), "v1alpha.App")
	proto.RegisterType((*Pod)(nil), "v1alpha.Pod")
	proto.RegisterType((*KeyValue)(nil), "v1alpha.KeyValue")
	proto.RegisterType((*PodFilter)(nil), "v1alpha.PodFilter")
	proto.RegisterType((*ImageFilter)(nil), "v1alpha.ImageFilter")
	proto.RegisterType((*GlobalFlags)(nil), "v1alpha.GlobalFlags")
	proto.RegisterType((*Info)(nil), "v1alpha.Info")
	proto.RegisterType((*Event)(nil), "v1alpha.Event")
	proto.RegisterType((*EventFilter)(nil), "v1alpha.EventFilter")
	proto.RegisterType((*GetInfoRequest)(nil), "v1alpha.GetInfoRequest")
	proto.RegisterType((*GetInfoResponse)(nil), "v1alpha.GetInfoResponse")
	proto.RegisterType((*ListPodsRequest)(nil), "v1alpha.ListPodsRequest")
	proto.RegisterType((*ListPodsResponse)(nil), "v1alpha.ListPodsResponse")
	proto.RegisterType((*InspectPodRequest)(nil), "v1alpha.InspectPodRequest")
	proto.RegisterType((*InspectPodResponse)(nil), "v1alpha.InspectPodResponse")
	proto.RegisterType((*ListImagesRequest)(nil), "v1alpha.ListImagesRequest")
	proto.RegisterType((*ListImagesResponse)(nil), "v1alpha.ListImagesResponse")
	proto.RegisterType((*InspectImageRequest)(nil), "v1alpha.InspectImageRequest")
	proto.RegisterType((*InspectImageResponse)(nil), "v1alpha.InspectImageResponse")
	proto.RegisterType((*ListenEventsRequest)(nil), "v1alpha.ListenEventsRequest")
	proto.RegisterType((*ListenEventsResponse)(nil), "v1alpha.ListenEventsResponse")
	proto.RegisterType((*GetLogsRequest)(nil), "v1alpha.GetLogsRequest")
	proto.RegisterType((*GetLogsResponse)(nil), "v1alpha.GetLogsResponse")
	proto.RegisterType((*FetchImagesRequest)(nil), "v1alpha.FetchImagesRequest")
	proto.RegisterType((*FetchImagesResponse)(nil), "v1alpha.FetchImagesResponse")
	proto.RegisterType((*RemoveImagesRequest)(nil), "v1alpha.RemoveImagesRequest")
	proto.RegisterType((*RemoveImagesResponse)(nil), "v1alpha.RemoveImagesResponse")
	proto.RegisterEnum("v1alpha.ImageType", ImageType_name, ImageType_value)
	proto.RegisterEnum("v1alpha.InsecureOption", InsecureOption_name, InsecureOption_value)
	proto.RegisterEnum("v1alpha.FetchOption", FetchOption_name, FetchOption_value)
	proto.RegisterEnum("v1alpha.AppState", AppState_name, AppState_value)
	proto.RegisterEnum("v1alpha.PodState", PodState_name, PodState_value)
	proto.RegisterEnum("v1alpha.EventType", EventType_name, EventType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for PublicAPI service

type PublicAPIClient interface {
	// GetInfo gets the rkt's information on the machine.
	GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error)
	// ListPods lists rkt pods on the machine.
	ListPods(ctx context.Context, in *ListPodsRequest, opts ...grpc.CallOption) (*ListPodsResponse, error)
	// InspectPod gets detailed pod information of the specified pod.
	InspectPod(ctx context.Context, in *InspectPodRequest, opts ...grpc.CallOption) (*InspectPodResponse, error)
	// ListImages lists the images on the machine.
	ListImages(ctx context.Context, in *ListImagesRequest, opts ...grpc.CallOption) (*ListImagesResponse, error)
	// InspectImage gets the detailed image information of the specified image.
	InspectImage(ctx context.Context, in *InspectImageRequest, opts ...grpc.CallOption) (*InspectImageResponse, error)
	// ListenEvents listens for the events, it will return a response stream
	// that will contain event objects.
	ListenEvents(ctx context.Context, in *ListenEventsRequest, opts ...grpc.CallOption) (PublicAPI_ListenEventsClient, error)
	// GetLogs gets the logs for a pod, if the app is also specified, then only the logs
	// of the app will be returned.
	//
	// If 'follow' in the 'GetLogsRequest' is set to 'true', then the response stream
	// will not be closed after the first response, the future logs will be sent via
	// the stream.
	GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (PublicAPI_GetLogsClient, error)
}

type publicAPIClient struct {
	cc *grpc.ClientConn
}

func NewPublicAPIClient(cc *grpc.ClientConn) PublicAPIClient {
	return &publicAPIClient{cc}
}

func (c *publicAPIClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...grpc.CallOption) (*GetInfoResponse, error) {
	out := new(GetInfoResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicAPI/GetInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAPIClient) ListPods(ctx context.Context, in *ListPodsRequest, opts ...grpc.CallOption) (*ListPodsResponse, error) {
	out := new(ListPodsResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicAPI/ListPods", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAPIClient) InspectPod(ctx context.Context, in *InspectPodRequest, opts ...grpc.CallOption) (*InspectPodResponse, error) {
	out := new(InspectPodResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicAPI/InspectPod", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAPIClient) ListImages(ctx context.Context, in *ListImagesRequest, opts ...grpc.CallOption) (*ListImagesResponse, error) {
	out := new(ListImagesResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicAPI/ListImages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAPIClient) InspectImage(ctx context.Context, in *InspectImageRequest, opts ...grpc.CallOption) (*InspectImageResponse, error) {
	out := new(InspectImageResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicAPI/InspectImage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAPIClient) ListenEvents(ctx context.Context, in *ListenEventsRequest, opts ...grpc.CallOption) (PublicAPI_ListenEventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_PublicAPI_serviceDesc.Streams[0], c.cc, "/v1alpha.PublicAPI/ListenEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &publicAPIListenEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PublicAPI_ListenEventsClient interface {
	Recv() (*ListenEventsResponse, error)
	grpc.ClientStream
}

type publicAPIListenEventsClient struct {
	grpc.ClientStream
}

func (x *publicAPIListenEventsClient) Recv() (*ListenEventsResponse, error) {
	m := new(ListenEventsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *publicAPIClient) GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (PublicAPI_GetLogsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_PublicAPI_serviceDesc.Streams[1], c.cc, "/v1alpha.PublicAPI/GetLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &publicAPIGetLogsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PublicAPI_GetLogsClient interface {
	Recv() (*GetLogsResponse, error)
	grpc.ClientStream
}

type publicAPIGetLogsClient struct {
	grpc.ClientStream
}

func (x *publicAPIGetLogsClient) Recv() (*GetLogsResponse, error) {
	m := new(GetLogsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for PublicAPI service

type PublicAPIServer interface {
	// GetInfo gets the rkt's information on the machine.
	GetInfo(context.Context, *GetInfoRequest) (*GetInfoResponse, error)
	// ListPods lists rkt pods on the machine.
	ListPods(context.Context, *ListPodsRequest) (*ListPodsResponse, error)
	// InspectPod gets detailed pod information of the specified pod.
	InspectPod(context.Context, *InspectPodRequest) (*InspectPodResponse, error)
	// ListImages lists the images on the machine.
	ListImages(context.Context, *ListImagesRequest) (*ListImagesResponse, error)
	// InspectImage gets the detailed image information of the specified image.
	InspectImage(context.Context, *InspectImageRequest) (*InspectImageResponse, error)
	// ListenEvents listens for the events, it will return a response stream
	// that will contain event objects.
	ListenEvents(*ListenEventsRequest, PublicAPI_ListenEventsServer) error
	// GetLogs gets the logs for a pod, if the app is also specified, then only the logs
	// of the app will be returned.
	//
	// If 'follow' in the 'GetLogsRequest' is set to 'true', then the response stream
	// will not be closed after the first response, the future logs will be sent via
	// the stream.
	GetLogs(*GetLogsRequest, PublicAPI_GetLogsServer) error
}

func RegisterPublicAPIServer(s *grpc.Server, srv PublicAPIServer) {
	s.RegisterService(&_PublicAPI_serviceDesc, srv)
}

func _PublicAPI_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAPIServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1alpha.PublicAPI/GetInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAPIServer).GetInfo(ctx, req.(*GetInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicAPI_ListPods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPodsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAPIServer).ListPods(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1alpha.PublicAPI/ListPods",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAPIServer).ListPods(ctx, req.(*ListPodsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicAPI_InspectPod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectPodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAPIServer).InspectPod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1alpha.PublicAPI/InspectPod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAPIServer).InspectPod(ctx, req.(*InspectPodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicAPI_ListImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAPIServer).ListImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1alpha.PublicAPI/ListImages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAPIServer).ListImages(ctx, req.(*ListImagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicAPI_InspectImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAPIServer).InspectImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1alpha.PublicAPI/InspectImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAPIServer).InspectImage(ctx, req.(*InspectImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicAPI_ListenEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PublicAPIServer).ListenEvents(m, &publicAPIListenEventsServer{stream})
}

type PublicAPI_ListenEventsServer interface {
	Send(*ListenEventsResponse) error
	grpc.ServerStream
}

type publicAPIListenEventsServer struct {
	grpc.ServerStream
}

func (x *publicAPIListenEventsServer) Send(m *ListenEventsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _PublicAPI_GetLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PublicAPIServer).GetLogs(m, &publicAPIGetLogsServer{stream})
}

type PublicAPI_GetLogsServer interface {
	Send(*GetLogsResponse) error
	grpc.ServerStream
}

type publicAPIGetLogsServer struct {
	grpc.ServerStream
}

func (x *publicAPIGetLogsServer) Send(m *GetLogsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _PublicAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1alpha.PublicAPI",
	HandlerType: (*PublicAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInfo",
			Handler:    _PublicAPI_GetInfo_Handler,
		},
		{
			MethodName: "ListPods",
			Handler:    _PublicAPI_ListPods_Handler,
		},
		{
			MethodName: "InspectPod",
			Handler:    _PublicAPI_InspectPod_Handler,
		},
		{
			MethodName: "ListImages",
			Handler:    _PublicAPI_ListImages_Handler,
		},
		{
			MethodName: "InspectImage",
			Handler:    _PublicAPI_InspectImage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListenEvents",
			Handler:       _PublicAPI_ListenEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetLogs",
			Handler:       _PublicAPI_GetLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

// Client API for PublicWriteOnlyAPI service

type PublicWriteOnlyAPIClient interface {
	// FetchImages fetches a container image into the image store.
	FetchImages(ctx context.Context, in *FetchImagesRequest, opts ...grpc.CallOption) (*FetchImagesResponse, error)
	// RemoveImages removes a container image from the image store.
	RemoveImages(ctx context.Context, in *RemoveImagesRequest, opts ...grpc.CallOption) (*RemoveImagesResponse, error)
}

type publicWriteOnlyAPIClient struct {
	cc *grpc.ClientConn
}

func NewPublicWriteOnlyAPIClient(cc *grpc.ClientConn) PublicWriteOnlyAPIClient {
	return &publicWriteOnlyAPIClient{cc}
}

func (c *publicWriteOnlyAPIClient) FetchImages(ctx context.Context, in *FetchImagesRequest, opts ...grpc.CallOption) (*FetchImagesResponse, error) {
	out := new(FetchImagesResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicWriteOnlyAPI/FetchImages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicWriteOnlyAPIClient) RemoveImages(ctx context.Context, in *RemoveImagesRequest, opts ...grpc.CallOption) (*RemoveImagesResponse, error) {
	out := new(RemoveImagesResponse)
	err := grpc.Invoke(ctx, "/v1alpha.PublicWriteOnlyAPI/RemoveImages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for PublicWriteOnlyAPI service

type PublicWriteOnlyAPIServer interface {
	// FetchImages fetches a container image into the image store.
	FetchImages(context.Context, *FetchImagesRequest) (*FetchImagesResponse, error)
	// RemoveImages removes a container image from the image store.
	RemoveImages(context.Context, *RemoveImagesRequest) (*RemoveImagesResponse, error)
}

func RegisterPublicWriteOnlyAPIServer(s *grpc.Server, srv PublicWriteOnlyAPIServer) {
	s.RegisterService(&_PublicWriteOnlyAPI_serviceDesc, srv)
}

func _PublicWriteOnlyAPI_FetchImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicWriteOnlyAPIServer).FetchImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1alpha.PublicWriteOnlyAPI/FetchImages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicWriteOnlyAPIServer).FetchImages(ctx, req.(*FetchImagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicWriteOnlyAPI_RemoveImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicWriteOnlyAPIServer).RemoveImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1alpha.PublicWriteOnlyAPI/RemoveImages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicWriteOnlyAPIServer).RemoveImages(ctx, req.(*RemoveImagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PublicWriteOnlyAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1alpha.PublicWriteOnlyAPI",
	HandlerType: (*PublicWriteOnlyAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FetchImages",
			Handler:    _PublicWriteOnlyAPI_FetchImages_Handler,
		},
		{
			MethodName: "RemoveImages",
			Handler:    _PublicWriteOnlyAPI_RemoveImages_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1778 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x58, 0xcd, 0x6e, 0xdb, 0xd8,
	0x15, 0xb6, 0xfe, 0xa5, 0x23, 0x47, 0xa6, 0x68, 0x27, 0x96, 0x9d, 0xcc, 0x8c, 0xc3, 0xb6, 0x83,
	0xa9, 0x17, 0xee, 0x8c, 0x67, 0x9a, 0x4d, 0x81, 0x22, 0xb2, 0x4d, 0x3b, 0x8a, 0x65, 0x49, 0x90,
	0xe5, 0xb4, 0x06, 0x0a, 0x10, 0xb4, 0x74, 0x65, 0x13, 0xa6, 0x48, 0x96, 0xa4, 0x9c, 0xb8, 0xcb,
	0xae, 0xba, 0xeb, 0x23, 0xf4, 0x11, 0xba, 0xec, 0x3b, 0x74, 0xd1, 0x87, 0x28, 0xd0, 0xf7, 0xe8,
	0xb9, 0x3f, 0x24, 0x2f, 0x29, 0x6a, 0x31, 0x40, 0x16, 0xd1, 0x39, 0x87, 0xdf, 0xf9, 0xff, 0xce,
	0x85, 0xa1, 0x61, 0x7a, 0xd6, 0x91, 0xe7, 0xbb, 0xa1, 0xab, 0xd6, 0x9e, 0x7e, 0x30, 0x6d, 0xef,
	0xc1, 0xd4, 0xde, 0x43, 0xb3, 0xb7, 0x30, 0xef, 0xc9, 0xb9, 0xeb, 0x2f, 0xcc, 0x50, 0x3d, 0x80,
	0x72, 0xf8, 0xec, 0x91, 0x4e, 0xe1, 0xa0, 0xf0, 0x5d, 0xeb, 0x58, 0x3d, 0x12, 0x66, 0x47, 0xcc,
	0x66, 0x82, 0x1a, 0x75, 0x0b, 0x6a, 0x4f, 0xc4, 0x0f, 0x2c, 0xd7, 0xe9, 0x14, 0xd1, 0xa8, 0xa1,
	0xfd, 0xb7, 0x00, 0x15, 0xa6, 0x56, 0x7f, 0x0d, 0xcd, 0x3b, 0x33, 0x20, 0xc6, 0x9c, 0x61, 0x31,
	0x8c, 0xe6, 0xf1, 0x4e, 0x1a, 0x43, 0xf8, 0x01, 0x28, 0x5a, 0x33, 0x0e, 0xa0, 0x6e, 0x42, 0xd9,
	0x31, 0x17, 0xa4, 0x53, 0x62, 0xbf, 0x24, 0xfc, 0x32, 0x13, 0x74, 0x40, 0xb1, 0x16, 0x9e, 0xeb,
	0x87, 0x46, 0x68, 0x2d, 0x48, 0x10, 0x9a, 0x0b, 0xaf, 0x53, 0x41, 0x4d, 0x49, 0x55, 0xa0, 0xbe,
	0x30, 0x1d, 0x6b, 0x8e, 0xc2, 0x4e, 0x15, 0x25, 0x9b, 0x14, 0x2a, 0xb0, 0xfe, 0x42, 0x3a, 0x35,
	0xa6, 0xff, 0x16, 0x9a, 0xa6, 0xe3, 0xb8, 0xa1, 0x19, 0x22, 0x5a, 0xd0, 0xa9, 0x1f, 0x94, 0x30,
	0x9e, 0x76, 0x1c, 0xcf, 0x25, 0x79, 0xfe, 0x64, 0xda, 0x4b, 0xa2, 0xbe, 0x85, 0xaa, 0x6d, 0xde,
	0x11, 0x3b, 0xe8, 0x34, 0xd6, 0x98, 0x68, 0x3f, 0x42, 0x6d, 0x40, 0xc2, 0xcf, 0xae, 0xff, 0x18,
	0x87, 0x5b, 0x88, 0x82, 0xb7, 0xbc, 0xa7, 0x9f, 0x92, 0x54, 0xf0, 0xd7, 0x3b, 0x9e, 0x8a, 0xf6,
	0xf7, 0x02, 0x94, 0xba, 0x9e, 0x97, 0xf9, 0xe2, 0x2b, 0xa8, 0x58, 0xb4, 0x12, 0xec, 0x93, 0xe6,
	0x71, 0x2b, 0x5d, 0x1f, 0xec, 0x40, 0x05, 0x73, 0x0c, 0x79, 0x39, 0x5a, 0x52, 0x2c, 0x88, 0x74,
	0x4d, 0x15, 0x6a, 0x1b, 0x1a, 0xe4, 0x8b, 0x15, 0x1a, 0x53, 0x77, 0x46, 0x58, 0x8d, 0xda, 0xd9,
	0x4c, 0x2b, 0xeb, 0xd2, 0xf8, 0x5b, 0x11, 0x4a, 0x23, 0x77, 0x26, 0xca, 0xcf, 0xe3, 0x69, 0x42,
	0xc9, 0x13, 0xbd, 0x68, 0xaf, 0xf7, 0x8e, 0x5f, 0x71, 0xef, 0xfb, 0x50, 0x36, 0x3d, 0x2f, 0x40,
	0xc7, 0xd4, 0xc7, 0xa6, 0x1c, 0x9e, 0xaa, 0x41, 0xdd, 0xe1, 0x55, 0x8a, 0x62, 0x50, 0x62, 0x7d,
	0x54, 0xbe, 0xd5, 0xa6, 0x65, 0x82, 0xaf, 0xad, 0x6b, 0x53, 0x0b, 0xaa, 0xd3, 0x7b, 0xdf, 0x5d,
	0x7a, 0xd8, 0x49, 0x1a, 0x38, 0x66, 0x31, 0xf5, 0x09, 0xc6, 0x34, 0x33, 0x70, 0xda, 0x1a, 0xac,
	0xe5, 0x28, 0xc3, 0xf8, 0x7d, 0x21, 0x03, 0x26, 0xdb, 0x81, 0xcd, 0xfb, 0xa9, 0xb1, 0x30, 0xfd,
	0x47, 0x2e, 0x6d, 0x52, 0xa9, 0xf6, 0x2d, 0xd4, 0x63, 0x64, 0x2c, 0x01, 0xfe, 0x5f, 0xd4, 0xe3,
	0x05, 0x54, 0x9e, 0xa8, 0x54, 0x8c, 0xf7, 0xbf, 0x0b, 0xd0, 0xc0, 0xe4, 0xcf, 0x2d, 0x3b, 0x24,
	0x3e, 0xb5, 0xb4, 0x66, 0x01, 0x5a, 0x96, 0xd0, 0x12, 0xe7, 0x86, 0x15, 0x2b, 0x40, 0xd3, 0x52,
	0x7e, 0xb5, 0xda, 0x74, 0xe9, 0x3c, 0x83, 0xb6, 0x3f, 0xc0, 0x9a, 0xd2, 0xaf, 0x50, 0xc4, 0xfa,
	0x6f, 0x50, 0xa0, 0x32, 0x13, 0xbd, 0x84, 0x17, 0xa2, 0x6e, 0xc2, 0xb2, 0xc2, 0xc4, 0x99, 0xc2,
	0x54, 0xd7, 0x15, 0x06, 0x57, 0x86, 0x17, 0x86, 0x17, 0xaf, 0xa1, 0xee, 0xc2, 0x96, 0xe7, 0xce,
	0x8c, 0x60, 0x79, 0x67, 0x44, 0x0a, 0x3a, 0xfc, 0x6c, 0x57, 0xc5, 0xba, 0xe7, 0xa4, 0x83, 0x9d,
	0xf1, 0x7c, 0x32, 0xb7, 0xbe, 0x88, 0x84, 0x58, 0x85, 0xd9, 0x42, 0xcb, 0xe1, 0xa3, 0xd5, 0x23,
	0x79, 0xc6, 0x58, 0xe3, 0xe8, 0x93, 0xf5, 0x59, 0x37, 0x77, 0xea, 0x2b, 0x68, 0xf1, 0x1d, 0xa6,
	0x1d, 0x98, 0xa3, 0x67, 0xd6, 0xfa, 0x12, 0x0d, 0x34, 0x96, 0xdf, 0x11, 0xe4, 0x8d, 0x9f, 0xbb,
	0xba, 0x18, 0xe1, 0x7c, 0x69, 0xdb, 0x22, 0xc2, 0x06, 0x4b, 0xf2, 0x1f, 0x98, 0xe4, 0x85, 0xed,
	0xde, 0x99, 0xf6, 0xb9, 0x6d, 0xde, 0x07, 0x34, 0xc9, 0x99, 0xe5, 0x8b, 0xee, 0xee, 0x41, 0x3b,
	0x78, 0x0e, 0x42, 0xb2, 0xc0, 0xf5, 0x71, 0xe6, 0xd6, 0xbd, 0x41, 0x55, 0xc5, 0x88, 0x68, 0x6c,
	0x77, 0x6a, 0xda, 0xb2, 0x86, 0x73, 0x12, 0x86, 0xb9, 0x0c, 0x88, 0x2f, 0x2b, 0x38, 0x37, 0xd1,
	0xbc, 0x9c, 0x80, 0x4c, 0x97, 0x3e, 0xb2, 0x1e, 0x75, 0xc6, 0x98, 0x89, 0xee, 0xf8, 0xcb, 0xd0,
	0x5f, 0x06, 0xa1, 0x81, 0xa5, 0x0a, 0x8c, 0xb9, 0xef, 0x2e, 0x8c, 0x87, 0x30, 0xf4, 0x02, 0x96,
	0x76, 0x5d, 0xf3, 0xa1, 0xdc, 0x73, 0xe6, 0xae, 0xba, 0x0d, 0x4d, 0xff, 0x31, 0x34, 0x22, 0xbe,
	0xe3, 0x11, 0xe2, 0xb8, 0xe2, 0xc8, 0x4c, 0x8d, 0x14, 0xcb, 0x52, 0x53, 0x64, 0xef, 0x58, 0xc8,
	0xe3, 0x3a, 0xc4, 0xc9, 0x66, 0x89, 0x0a, 0xe7, 0xe5, 0x0c, 0xe3, 0x4a, 0x55, 0x40, 0x9f, 0x15,
	0xfd, 0x89, 0x38, 0xeb, 0x29, 0x9e, 0x69, 0x19, 0xc5, 0x67, 0xc8, 0x99, 0x86, 0x2f, 0x1c, 0xe2,
	0x2f, 0x4a, 0xc2, 0xcc, 0x51, 0x49, 0xfd, 0x06, 0xca, 0x33, 0x33, 0x34, 0xd7, 0xd3, 0x4d, 0x08,
	0x4d, 0x86, 0x2a, 0xa6, 0xed, 0x2d, 0x54, 0xa8, 0x67, 0x3e, 0x6f, 0xf9, 0xae, 0xc5, 0x40, 0xf2,
	0xf1, 0xc3, 0x4d, 0x94, 0x27, 0x8f, 0xee, 0xb6, 0xe5, 0x4c, 0x89, 0x21, 0x85, 0x80, 0xb2, 0xa5,
	0x13, 0x5a, 0x36, 0x97, 0xb1, 0xb3, 0xa0, 0x29, 0xd0, 0xba, 0x20, 0x21, 0x2d, 0xf0, 0x98, 0xfc,
	0x79, 0x89, 0x3c, 0xa3, 0x1d, 0xc1, 0x56, 0x2c, 0x09, 0x3c, 0x1c, 0x28, 0xa2, 0xbe, 0x46, 0xa6,
	0xc6, 0xdf, 0xe2, 0x48, 0xbd, 0x48, 0x48, 0x18, 0x85, 0xda, 0x39, 0x6c, 0xf5, 0xad, 0x20, 0xc4,
	0x2d, 0x0e, 0x04, 0x84, 0xfa, 0x0b, 0xa8, 0xcd, 0x59, 0x16, 0x3c, 0xfa, 0xa6, 0x14, 0x7d, 0xc2,
	0x0e, 0xc8, 0x50, 0x33, 0x12, 0x9a, 0x96, 0xcd, 0x8a, 0x57, 0x47, 0xbf, 0x4a, 0x82, 0x23, 0x1c,
	0x23, 0x7f, 0xe2, 0x6e, 0x46, 0x28, 0x9b, 0x32, 0x8a, 0xf6, 0x0d, 0xb4, 0x7b, 0x4e, 0xe0, 0x91,
	0x29, 0xfd, 0x24, 0xf2, 0x2c, 0x71, 0xb5, 0xf6, 0x1b, 0x50, 0x65, 0x03, 0x01, 0xb9, 0x87, 0x0c,
	0xee, 0xce, 0x44, 0x2a, 0x69, 0xc4, 0x8f, 0xd0, 0xa6, 0x11, 0xb0, 0x9d, 0x8f, 0x73, 0xf9, 0x55,
	0x36, 0x97, 0xec, 0x8d, 0xce, 0xcf, 0xe6, 0x27, 0x50, 0x65, 0x2c, 0xe1, 0xfc, 0x6b, 0xa8, 0x32,
	0x3a, 0x8b, 0xb0, 0x32, 0xf7, 0x4c, 0x7b, 0x0b, 0xdb, 0x22, 0x64, 0xf6, 0x3b, 0x2f, 0xab, 0xdf,
	0xc2, 0x4e, 0xda, 0x44, 0x40, 0xc7, 0x97, 0xb2, 0x90, 0x77, 0x29, 0xb5, 0xdf, 0xc1, 0x36, 0x8d,
	0x87, 0x38, 0x6c, 0x7c, 0xe2, 0xec, 0x7e, 0x09, 0x55, 0x9e, 0xdd, 0xca, 0x03, 0x44, 0x9a, 0x45,
	0xed, 0x1d, 0xec, 0xa4, 0x3f, 0x4e, 0xd2, 0x21, 0x4c, 0xb2, 0x92, 0x0e, 0x33, 0xd4, 0x9e, 0xd9,
	0x70, 0xf5, 0xdd, 0xfb, 0xd8, 0x1f, 0x96, 0x89, 0x92, 0x6d, 0x7c, 0x4f, 0x91, 0x20, 0x23, 0xca,
	0x17, 0x3b, 0x84, 0x73, 0x6c, 0x5b, 0x0e, 0x9b, 0xe3, 0xc2, 0x77, 0x15, 0xfa, 0xc1, 0xdc, 0xb5,
	0x6d, 0xf7, 0x33, 0x9b, 0xe1, 0x7a, 0x66, 0xae, 0x2b, 0x39, 0x73, 0xcd, 0xc8, 0x52, 0x3b, 0x60,
	0x53, 0xcc, 0x5d, 0x8b, 0x68, 0x63, 0x64, 0xc6, 0xe0, 0xda, 0x7f, 0x0a, 0xa0, 0x9e, 0x93, 0x70,
	0xfa, 0x90, 0xee, 0x77, 0xbc, 0x47, 0x9c, 0xe7, 0xbf, 0x47, 0xd2, 0x8d, 0x48, 0xcb, 0xf5, 0xc2,
	0x88, 0x63, 0x5a, 0xc7, 0xbb, 0xd2, 0x16, 0x70, 0xfd, 0x90, 0xa9, 0x29, 0xcf, 0xcc, 0x29, 0x6c,
	0x64, 0xce, 0x1f, 0x07, 0x49, 0x61, 0x99, 0x4f, 0x61, 0xbb, 0x96, 0xfa, 0x78, 0xb2, 0x78, 0xfd,
	0x3e, 0x5b, 0xe1, 0x83, 0x31, 0x23, 0x1e, 0x27, 0xcb, 0x3a, 0xa5, 0x64, 0xbc, 0xe3, 0x33, 0xac,
	0xae, 0x15, 0x93, 0x2f, 0x7f, 0x1a, 0x68, 0x1a, 0x6c, 0xa7, 0xf2, 0x11, 0x69, 0xcb, 0x67, 0x4b,
	0xfb, 0x01, 0xb6, 0xc7, 0x64, 0xe1, 0x3e, 0x91, 0x74, 0xd2, 0xa9, 0xd3, 0x16, 0x57, 0x80, 0x11,
	0x8b, 0xf6, 0x0a, 0x76, 0xd2, 0x9f, 0x70, 0xdc, 0x43, 0x02, 0x8d, 0xe4, 0xa1, 0xdb, 0xc1, 0xa9,
	0xbc, 0xea, 0x5e, 0xe8, 0xc6, 0xe4, 0x76, 0xa4, 0x1b, 0x37, 0x83, 0x33, 0xfd, 0xbc, 0x37, 0xd0,
	0xcf, 0x94, 0x0d, 0xe4, 0xe2, 0x2d, 0x49, 0xd3, 0x1d, 0x8d, 0x4e, 0x95, 0x02, 0xde, 0xf0, 0xb6,
	0x24, 0x3c, 0x1b, 0x9e, 0x5e, 0xea, 0x63, 0xa5, 0x88, 0x8d, 0x6c, 0x49, 0xe2, 0xe1, 0x69, 0x4f,
	0x29, 0x1d, 0xe2, 0x93, 0xa2, 0x95, 0xa9, 0x30, 0x75, 0x36, 0xb8, 0xd6, 0x4f, 0x6f, 0xc6, 0x68,
	0x34, 0x9a, 0xf4, 0x86, 0x03, 0x63, 0x30, 0x1c, 0xe8, 0xe8, 0x6c, 0x17, 0xf7, 0x27, 0xa3, 0xe9,
	0xf6, 0xfb, 0xe8, 0x70, 0x0f, 0x5e, 0x66, 0x15, 0xcc, 0x13, 0x3a, 0xcd, 0xf9, 0x66, 0xd2, 0xbf,
	0x56, 0xca, 0xc8, 0x7a, 0xbb, 0x59, 0x05, 0xfe, 0x3b, 0xeb, 0x5d, 0x5f, 0x2a, 0xf5, 0xbc, 0x18,
	0x3e, 0x4c, 0x26, 0x23, 0x45, 0x41, 0xce, 0x7a, 0x95, 0xd5, 0x8c, 0x6e, 0x4e, 0x2e, 0xf5, 0x5b,
	0xe5, 0xe0, 0xf0, 0x4f, 0xd0, 0x94, 0xdb, 0x8f, 0x65, 0x38, 0xd7, 0x27, 0xa7, 0x1f, 0x32, 0x59,
	0x60, 0xb0, 0x19, 0xb1, 0x71, 0x3d, 0x19, 0x8e, 0x75, 0xcc, 0x03, 0x63, 0x4a, 0xa9, 0x86, 0x83,
	0xfe, 0xad, 0x50, 0x16, 0x0f, 0x47, 0x50, 0x8f, 0xdf, 0xbd, 0x98, 0x15, 0xd6, 0x1a, 0x55, 0xdd,
	0x49, 0xba, 0x1f, 0xe8, 0x33, 0x51, 0x8c, 0x6f, 0x06, 0x83, 0xde, 0xe0, 0x02, 0x81, 0x77, 0x40,
	0x49, 0xc4, 0xfa, 0x1f, 0x7b, 0x13, 0x34, 0x2e, 0x1e, 0xfe, 0xaf, 0x00, 0xf5, 0xf8, 0x79, 0x86,
	0x90, 0xa3, 0xe1, 0x59, 0x0e, 0x24, 0x7e, 0x9b, 0x28, 0xf4, 0xab, 0x93, 0xf1, 0xed, 0x10, 0x11,
	0x53, 0xe6, 0xa3, 0xb1, 0x3e, 0xea, 0x8e, 0xa9, 0xab, 0x22, 0xbe, 0x03, 0xd4, 0xac, 0x02, 0x61,
	0x4a, 0x34, 0xb2, 0x44, 0x1e, 0x45, 0x56, 0xc6, 0x1d, 0xd9, 0x4b, 0xc4, 0xdd, 0x93, 0xe1, 0x18,
	0x43, 0x8b, 0x3e, 0x53, 0x2a, 0x19, 0xe7, 0x3c, 0xf0, 0x6a, 0xda, 0xc7, 0x99, 0xde, 0xd7, 0x27,
	0x14, 0xac, 0x96, 0xf6, 0x71, 0xd1, 0x1d, 0x9f, 0xd0, 0x19, 0xa8, 0x1f, 0xfe, 0xab, 0x08, 0x8d,
	0xe4, 0xae, 0x62, 0x6f, 0xf5, 0x4f, 0xfa, 0x60, 0xb2, 0x3a, 0xcc, 0x58, 0x7e, 0x49, 0x43, 0x91,
	0xe2, 0xf8, 0x0b, 0xf8, 0xa0, 0xff, 0x3a, 0x5f, 0x19, 0x45, 0x8d, 0xb9, 0xe3, 0x70, 0x64, 0x6c,
	0x30, 0x14, 0xa6, 0x2b, 0xd1, 0xb6, 0x67, 0x74, 0x22, 0x9d, 0x32, 0xd2, 0xf4, 0x41, 0x46, 0x25,
	0x62, 0x37, 0x4e, 0x87, 0xfd, 0xbe, 0x7e, 0x4a, 0xad, 0x2a, 0x19, 0x70, 0xd1, 0xce, 0x31, 0x2f,
	0x48, 0x1a, 0x9c, 0xea, 0x04, 0x78, 0x8d, 0x16, 0x58, 0x52, 0xf1, 0x05, 0xec, 0x5d, 0x8d, 0x78,
	0xc8, 0x75, 0xf5, 0x0d, 0x74, 0x56, 0xd4, 0x63, 0xfd, 0x6a, 0xf8, 0x09, 0xb5, 0x8d, 0xe3, 0xbf,
	0x96, 0xf1, 0xc5, 0xbf, 0xbc, 0xb3, 0xad, 0x69, 0x77, 0xd4, 0x53, 0x7f, 0x0f, 0x35, 0xf1, 0x76,
	0x50, 0x13, 0x7e, 0x4c, 0xbf, 0x2f, 0xf6, 0x3b, 0xab, 0x0a, 0xce, 0x28, 0xda, 0x86, 0xda, 0x85,
	0x7a, 0xf4, 0x06, 0x50, 0x13, 0xbb, 0xcc, 0xf3, 0x62, 0x7f, 0x2f, 0x47, 0x13, 0x43, 0x5c, 0x00,
	0x24, 0x57, 0x5f, 0xdd, 0x97, 0x59, 0x3a, 0xfd, 0x56, 0xd8, 0x7f, 0x9d, 0xab, 0x93, 0x81, 0x92,
	0x0b, 0x2e, 0x01, 0xad, 0x3c, 0x11, 0x24, 0xa0, 0xd5, 0x93, 0x8f, 0x40, 0x57, 0xb0, 0x29, 0x5f,
	0x6c, 0xf5, 0x4d, 0xd6, 0xaf, 0x7c, 0xeb, 0xf7, 0xbf, 0x5a, 0xa3, 0x8d, 0xe1, 0x86, 0xb0, 0x29,
	0x1f, 0x63, 0x09, 0x2e, 0xe7, 0xc0, 0x4b, 0x70, 0x79, 0x17, 0x5c, 0xdb, 0xf8, 0xbe, 0xa0, 0xbe,
	0x67, 0x4d, 0xa3, 0xa7, 0x32, 0xdd, 0x34, 0xe9, 0x6e, 0xa7, 0x9b, 0x26, 0x5f, 0x55, 0x8a, 0x70,
	0xfc, 0x4f, 0x3c, 0xa5, 0x7c, 0x08, 0xfe, 0xe0, 0x5b, 0x21, 0x19, 0x3a, 0xf6, 0x33, 0x9d, 0x86,
	0x8f, 0x82, 0xed, 0x44, 0x09, 0x5f, 0xa7, 0x4f, 0x60, 0xba, 0x86, 0x6f, 0xf2, 0x95, 0x72, 0x11,
	0xe5, 0x2b, 0x24, 0x65, 0x9d, 0x73, 0xcf, 0xa4, 0xac, 0xf3, 0x4e, 0x97, 0xb6, 0x71, 0x57, 0x65,
	0x7f, 0xd9, 0xf9, 0xf1, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x8a, 0x94, 0xc9, 0xdb, 0xe6, 0x11,
	0x00, 0x00,
}
