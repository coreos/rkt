// Copyright 2015 The rkt Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// To compile, run 'protoc -I api/v1 api/v1/api.proto --go_out=plugins=grpc:api/v1' in rkt root directory.

syntax = "proto3";

package v1;

// ImageType defines the supported image type.
enum ImageType {
        IMAGE_TYPE_UNDEFINED = 0;
        IMAGE_TYPE_APPC      = 1;
        IMAGE_TYPE_DOCKER    = 2;
        IMAGE_TYPE_OCI       = 3;
}

// ImageFormat defines the format of the image.
message ImageFormat {
        // Type of the image, required.
        ImageType type = 1;

        // Version of the image format, required.
        string version = 2;
}

// Image describes the image's information.
message Image {
        // The format of the image.
        ImageFormat format = 1;

        // ID of the image,  a string of the format 'hash-value'.
        // Currently the only permitted hash algorithm is sha512.
        string id = 2;

        // Name of the image in the image manifest, e.g. 'coreos.com/etcd'.
        string name = 3;

        // Version of the image, e.g. 'latest', '2.0.10'.
        string version = 4;

        // The timestamp of when the image is imported.
        int64 import_timestamp = 5;

        // The JSON-encoded byte array that represents the manifest.
        bytes manifest = 6;
}

// Network describes the network information of a pod.
message Network {
        // The name of the network that a pod belongs to.
        string name = 1;

        // The pod’s IPv4 address within the network, optional if IPv6 address is given.
        string ipv4 = 2;

        // The pod’s IPv6 address within the network, optional if IPv4 address is given.
        string ipv6 = 3;
}

// AppState defines the possible states of the app.
enum AppState {
        APP_STATE_UNDEFINED = 0;
        APP_STATE_RUNNING   = 1;
        APP_STATE_EXITED    = 2;
}

// App describes the information of an app that's running in a pod.
message App {
        // Name of the app.
        string name = 1;

        // The image used by the app. This may only contain the image id if it is returned
        // by ListPods().
        Image image = 2;

        // The state of the app. Only returned by InspectPod().
        AppState state = 3;

        // The exit code of the app.
        // Undefined if the app is not returned by InspectPod(), or the app has not exited.
        sint32 exit_code = 4;
}

// PodState defines the possible states of the pod.
// See https://github.com/coreos/rkt/blob/master/Documentation/devel/pod-lifecycle.md for detailed
// explaination about each state.
enum PodState {
        POD_STATE_UNDEFINED = 0;

        // States that before the pod is running.
        POD_STATE_EMBRYO    = 1; // Pod is created, and hasn't entering preparing state.
        POD_STATE_PREPARING = 2; // Pod locked 'pods/prepare/$uuid', it is being prepared.
        POD_STATE_PREPARED  = 3; // Pod unlocked 'pod/prepare/$uuid', it has been successfully prepared, ready to enter running state.

        // State that indicates the pod is running.
        POD_STATE_RUNNING = 4; // Pod locked 'pod/run/$uuid', it is running.

        // States that indicates the pod is exited, and will never run.
        POD_STATE_ABORTED_PREPARE = 5; // Pod unlocked 'pod/prepare/$uuid', the preparing step failed, it will never run.
        POD_STATE_EXITED          = 6; // Pod unlocked 'pod/run/$uuid', the run exited running.
        POD_STATE_DELETING        = 7; // Pod locked 'pod/garbage/$uuid'(prepare failed) or 'pod/exited-garbage/$uuid'(exited), the pod is being garbage collected.
        POD_STATE_GARBAGE         = 8; // Pod unlocked 'pod/garbage/$uuid'(prepare failed) or 'pod/exited-garbage/$uuid'(exited), the pod is garbage collected.
}

// Pod describes a pod's information.
message Pod {
        // The ID of the pod, it's in the form of a UUID.
        string id = 1;

        // The PID of the pod. Undefined if the Pod is not returned by InspectPod().
        sint32 pid = 2;

        // The state of the pod.
        PodState state = 3;

        // The list of apps in the pod.
        repeated App apps = 4;

        // The network information of the pod. Note that a pod can be in multiple networks.
        repeated Network networks = 5;

        // The JSON-encoded byte array that represetns the pod manifest of the pod.
        bytes manifest = 6;
}

// KeyValue is the type used by annotations and labels in PodFilter and ImageFilter.
message KeyValue {
        // The key of the key-value pair.
        string Key = 1;
        // The value of the key-value pair.
        string value = 2;
}

// PodFilter defines the condition that the returned pods need to satisfy in ListPods().
// The conditions are combined by 'AND'.
message PodFilter {
        // If not empty, then the returned pods must be in one of these states.
        repeated PodState states = 1;

        // If not empty, then the returned pods must have one of these names in the apps.
        repeated string app_names = 2;

        // If not empty, then the returned pods must contain at least one of these image names in the apps.
        repeated string image_names = 3;

        // If not empty, then the returned pods must be in at least one of these networks.
        repeated string network_names = 4;

        // If not empty, then the returned pods must contain all the listed annotations.
        repeated KeyValue annotations = 5;
}

// ImageFilter defines the condition that the returned images need to satisfy in ListImages().
// The conditions are combined by 'AND'.
message ImageFilter {
        // If not empty, then the returned images must have the listed ids.
        repeated string ids = 1;

        // if not empty, then the returned images must have one of the listed prefixes.
        repeated string prefixes = 2;

        // If not empty, then the returned images must contain one of the listed names as the base name.
        // For example, both 'coreos.com/etcd' and 'k8s.io/etcd' will be returned if 'etcd' is included,
        // however 'etcd-backup' will not be returned.
        repeated string base_names = 3;

        // If not empty, then the returned images' names must contain one of the listed keywords.
        // For example, both 'kubernetes-etcd', 'etcd:latest' will be returned if 'etcd' is included,
        repeated string keywords = 4;

        // If not empty, then the returned images must have one of the listed labels.
        repeated KeyValue labels = 5;

        // If set, then the returned images must be imported after this timestamp.
        int64 imported_after = 6;

        // If set, then the returned images must be imported before this timestamp.
        int64 imported_before = 7;

        // If not empty, then the returned images must contain all the listed annotations.
        repeated KeyValue annotations = 8;
}

// Info describes the information of rkt on the machine.
message Info {
        // Version of the rkt. In the form of Semantic Versioning (http://semver.org/).
        string rkt_version = 1;

        // Version of the appc. In the form of Semantic Versioning (http://semver.org/).
        string appc_version = 2;
}

// EventType defines the type of the events that will be received via ListenEvents().
enum EventType {
        EVENT_TYPE_UNDEFINED = 0;

        // Pod events.
        EVENT_TYPE_POD_PREPARED          = 1;
        EVENT_TYPE_POD_PREPARE_ABORTED   = 2;
        EVENT_TYPE_POD_STARTED           = 3;
        EVENT_TYPE_POD_EXITED            = 4;
        EVENT_TYPE_POD_GARBAGE_COLLECTED = 5;

        // App events.
        EVENT_TYPE_APP_STARTED = 6;
        EVENT_TYPE_APP_EXITED  = 7; // (XXX)yifan: Maybe also return exit code in the event object?

        // Image events.
        EVENT_TYPE_IMAGE_IMPORTED = 8;
        EVENT_TYPE_IMAGE_REMOVED  = 9;
}

// Event describes the events that will be received via ListenEvents().
message Event {
        // Type of the event.
        EventType type = 1;

        // ID of the subject that causes the event.
        // If the event is a pod or app event, the id is the pod's uuid.
        // If the event is an image event, the id is the image's id.
        string id = 2;

        // Name of the subject that causes the event.
        // If the event is a pod event, the name is the pod's name.
        // If the event is an app event, the name is the app's name.
        // If the event is an image event, the name is the image's name.
        string from = 3;

        // Timestamp of when the event happens.
        int64 time = 4;

        // Data of the event, in the form of key-value pairs.
        map<string, string> data = 5;
}

// EventFilter defines the condition that the returned events needs to satisfy in ListImages().
// The condition are combined by 'AND'.
message EventFilter {
        // If not empty, then only returns the events that have the listed types.
        repeated EventType types = 1;

        // If not empty, then only returns the events whose 'id' is included in the listed ids.
        repeated string ids = 2;

        // If not empty, then only returns the events whose 'from' is included in the listed names.
        repeated string names = 3;

        // If set, then only returns the events after this timestamp.
        // If the server starts after since_time, then only the events happened after the start of the server will be returned.
        // If since_time is a future timestamp, then no events will be returned until that time.
        int64 since_time = 4;

        // If set, then only returns the events before this timestamp.
        // If it is a future timestamp, then the event stream will be closed at that moment.
        int64 until_time = 5;
}

// The request for GetInfo().
message GetInfoRequest {}

// The response for GetInfo().
message GetInfoResponse {
        Info info = 1;
}

// The request for ListPods().
message ListPodsRequest {
        PodFilter filter = 1;
}

// The response for ListPods().
message ListPodsResponse {
        repeated Pod pods = 1;
}

// The request for InspectPod().
message InspectPodRequest {
        // ID of the pod that we are querying status for.
        string id = 1;
}

// The response for InspectPod().
message InspectPodResponse {
        Pod pod = 1;
}

// The request for ListImages().
message ListImagesRequest {
        ImageFilter filter = 1;
}

// The response for ListImages().
message ListImagesResponse {
        repeated Image images = 1;
}

// The request for InspectImage().
message InspectImageRequest {
        string id = 1;
}

// The response for InspectImage().
message InspectImageResponse {
        Image image = 1;
}

// The request for ListenEvents().
message ListenEventsRequest {
        EventFilter filter = 1;
}

// The response for ListenEvents().
message ListenEventsResponse {
        repeated Event events = 1; // Aggregate multiple events to reduce round trips.
}

// The request for AddEvent().
message AddEventRequest {
        Event event = 1;
}

// The response for AddEvent().
message AddEventResponse {}

// The request for GetLogs().
message GetLogsRequest {
        // The id of the pod to get logs from.
        string pod_id = 1;

        // The name of the app with the pod to get logs from.
        // If not set, then the logs of all the apps within
        // the pod will be returned.
        string app_name = 2;

        // The number of most recent lines to return.
        int32 lines = 3;

        // If true, then a response stream will not be closed,
        // and new log response will be sent via the stream.
        bool follow = 4;

        // If set, then only the logs after the timestamp will
        // be returned.
        int64 since_time = 5;

        // If set, then only the logs before the timestamp will
        // be returned.
        int64 until_time = 6;
}

// The response for GetLogs().
message GetLogsResponse {
        // The list of log lines that returned.
        repeated string lines = 1;
}

// PublicAPI defines the read-only APIs that will be supported.
// These will be handled over TCP sockets.
service PublicAPI {
        // GetInfo gets the rkt's information on the machine.
        rpc GetInfo (GetInfoRequest) returns (GetInfoResponse) {}

        // ListPods lists rkt pods on the machine.
        rpc ListPods (ListPodsRequest) returns (ListPodsResponse) {}

        // InspectPod gets detailed pod information of the specified pod.
        rpc InspectPod (InspectPodRequest) returns (InspectPodResponse) {}

        // ListImages lists the images on the machine.
        rpc ListImages (ListImagesRequest) returns (ListImagesResponse) {}

        // InspectImage gets the detailed image information of the image.
        rpc InspectImage (InspectImageRequest) returns (InspectImageResponse) {}

        // ListenEvents listens for the intereted events, it will return a response stream
        // that will contain event objects.
        rpc ListenEvents (ListenEventsRequest) returns (stream ListenEventsResponse) {}

        // GetLogs gets the logs for a pod, if the app is also specified, then only the logs
        // of the app will be returned.
        //
        // If 'follow' in the 'GetLogsRequest' is set to 'true', then the response stream
        // will not be closed after the first response, the future logs will be sent via
        // the stream.
        rpc GetLogs(GetLogsRequest) returns (stream GetLogsResponse) {}
}

// InternalAPI defines the APIs for the internal pods, e.g. reporting events.
// These will be handled over UNIX sockets.
service InternalAPI {
        // AddEvent adds one event to the events list so that it can be retrieved by ListenEvents().
        rpc AddEvent(AddEventRequest) returns (AddEventResponse) {}
}
